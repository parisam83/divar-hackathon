// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: post_purchase.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgconn"
)

const checkUserPurchase = `-- name: CheckUserPurchase :one
SELECT 
    EXISTS (
        SELECT 1 
        FROM post_purchase 
        WHERE user_id = $1 AND post_token = $2
    ) AS has_purchased
`

type CheckUserPurchaseParams struct {
	UserID    string `db:"user_id" json:"user_id"`
	PostToken string `db:"post_token" json:"post_token"`
}

func (q *Queries) CheckUserPurchase(ctx context.Context, arg CheckUserPurchaseParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkUserPurchase, arg.UserID, arg.PostToken)
	var has_purchased bool
	err := row.Scan(&has_purchased)
	return has_purchased, err
}

const insertPostPurchase = `-- name: InsertPostPurchase :execresult
INSERT INTO post_purchase (user_id,post_token)
VALUES ($1, $2)
ON CONFLICT (user_id, post_token)
DO UPDATE SET
    purchased_at = CURRENT_TIMESTAMP
`

type InsertPostPurchaseParams struct {
	UserID    string `db:"user_id" json:"user_id"`
	PostToken string `db:"post_token" json:"post_token"`
}

func (q *Queries) InsertPostPurchase(ctx context.Context, arg InsertPostPurchaseParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, insertPostPurchase, arg.UserID, arg.PostToken)
}
